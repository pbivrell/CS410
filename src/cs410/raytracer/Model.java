package cs410.raytracer;

import cs410.debugging.Debug;
import cs410.matrix.Helper;
import Jama.Matrix;


import java.lang.Math;
import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.Scanner;
import java.io.File;
import java.io.IOException;

public class Model{
    private static final boolean DEBUG_ENABLED = true;
    private static final Debug d = new Debug(DEBUG_ENABLED);
    private String faces = "";
    private Matrix objM;
    private String modelFile;

    public String getModelFile(){
        return modelFile;
    }

    public String toString(){
        String res = "# Blender v2.79 (sub 0) OBJ File: '" + modelFile + "'\n# Generated by cs410.raytracer.Model (Paul Bivrell)\n";
        double[][] object = objM.getArray();
        for(int i = 0; i < object[0].length; i++){
            res += String.format("v %.7f %.7f %.7f\n", object[0][i], object[1][i], object[2][i]);
        }
        res += faces;
        return res;
    }

    public Model(double wx, double wy, double wz, int theta, double scale, double tx, double ty, double tz, String file){
        modelFile = file.substring(0, file.lastIndexOf("."));
        d.print("Constructing Model with object file: ", file);
        try (Scanner s = new Scanner(new File(file))) {
            objM = BuildObj(s,file);
        }catch(IOException e){
            System.err.printf("[Fatal Error]: failed to read file [%s] reason: %s\n", file, e);
            System.exit(-1);
            objM = null;
        }
        Matrix tMatrix = TransformationMatrix(wx, wy, wz, theta, scale, tx, ty, tz);
        
        d.print("Obj:\n",Helper.printMatrix(objM));
        d.print("T:\n",Helper.printMatrix(tMatrix));
        objM = tMatrix.times(objM);
        d.print("RES:\n",Helper.printMatrix(objM));
    }


    public Matrix TransformationMatrix(double wx, double wy, double wz, int theta, double scale, double tx, double ty, double tz){
        Matrix scaleM = ScaleMatrix(scale);
        Matrix transM = TranslationMatrix(tx,ty,tz);
        Matrix rotM = RotationMatrix(wx, wy, wz, theta);
        rotM = makeHomogeneous(rotM);
        d.print("ROT:\n",Helper.printMatrix(rotM));
        d.print("Trans:\n",Helper.printMatrix(transM));
        d.print("Scale:\n",Helper.printMatrix(scaleM));
        return (transM.times(scaleM)).times(rotM);
    }

    public Matrix makeHomogeneous(Matrix m){
        Matrix res = Matrix.identity(4,4);
        for(int i = 0; i < 3; i++){
            for(int j = 0; j < 3; j++){
                res.set(i,j, m.get(i,j));
            }
        }
        return res;
    }

    public Matrix ScaleMatrix(double scale){
        Matrix scaleM = Matrix.identity(4,4);
        scaleM.set(0,0,scale);
        scaleM.set(1,1,scale);
        scaleM.set(2,2,scale);
        return scaleM;
    }

    public Matrix TranslationMatrix(double tx, double ty, double tz){
        Matrix transM = Matrix.identity(4,4);
        transM.set(0,3, tx);
        transM.set(1,3, ty);
        transM.set(2,3, tz);
        return transM;
    }

    public Matrix makeUnitLength(Matrix m){
        d.print(m.getColumnDimension());
        d.print("NORM:",m.norm2());
        if(m.norm1() == 0){
            return m;
        }
        return m.times(1/m.norm2());
    }

    public Matrix crossProduct(Matrix u, Matrix v){
        double u1, u2, u3, v1, v2, v3;
        u1 = u.get(0,0); u2 = u.get(0,1); u3 = u.get(0,2);
        v1 = v.get(0,0); v2 = v.get(0,1); v3 = v.get(0,2);

        double uvi, uvj, uvk;
        uvi = u2 * v3 - v2 * u3;
        uvj = v1 * u3 - u1 * v3;
        uvk = u1 * v2 - v1 * u2;

        return new Matrix(new double[] { uvi, uvj, uvk },1);
    }

    public Matrix RotationMatrix(double wx, double wy, double wz, int theta){
        Matrix wV = new Matrix(new double[]{wx, wy, wz},1);
        d.print("In:\n", Helper.printMatrix(wV));
        wV = makeUnitLength(wV);
        d.print("Z:",Helper.printMatrix(wV));
        Matrix uV = wV.copy();
        double uV0, uV1, uV2;
        uV0 = Math.abs(uV.get(0,0)); uV1 = Math.abs(uV.get(0,1)); uV2 = Math.abs(uV.get(0,2));
        d.print("COORDS:",uV0, uV1, uV2);

        int min = Math.min(uV0, uV1) == uV1 ? (Math.min(uV1, uV2) == uV2 ? 2 : 1) : (Math.min(uV0,uV2) == uV2 ? 2 :0);
        d.print("Min index:", min);
        
        uV.set(0, min, 1.0);
        d.print("X':",Helper.printMatrix(uV));
        uV = crossProduct(wV, uV);
        d.print("X'':",Helper.printMatrix(uV));
        uV = makeUnitLength(uV);
        d.print("X:",Helper.printMatrix(uV));
        Matrix vV = crossProduct(wV, uV);
        d.print("Y:",Helper.printMatrix(vV));
        double[][] raw_matrix = new double[][] { uV.getArray()[0], vV.getArray()[0], wV.getArray()[0] };
        Matrix rotM = new Matrix(raw_matrix);
        d.print("ROT:\n", Helper.printMatrix(rotM));
        Matrix angleM = Matrix.identity(3,3);
        double cos_a = Math.cos(Math.toRadians(theta));
        double sin_a = Math.sin(Math.toRadians(theta));
        angleM.set(0, 0, cos_a); angleM.set(0,1, -sin_a);
        angleM.set(1, 0, sin_a); angleM.set(1,1, cos_a);
        d.print("AngleM:\n",Helper.printMatrix(angleM));
        return (rotM.transpose().times(angleM)).times(rotM);
    }

    public Matrix BuildObj(Scanner s, String file){
        assert(s != null);
        // TODO Use faces when printing back the file
        String faces = "";

        Scanner lineScan;
        ArrayList<double[]> matrix = new ArrayList<double[]>();

        while(s.hasNextLine()){
            String line = s.nextLine();
            if(line.startsWith("v ")){
                try {
                    lineScan = new Scanner(line); lineScan.next();
                    matrix.add(new double[] { lineScan.nextDouble(), lineScan.nextDouble(), lineScan.nextDouble(), 1 });
                }catch (InputMismatchException e){
                    System.err.printf("[Fatal Error]: invalid line in file [%s] : [%s]\n", file, line);
                    System.exit(-1);
                }
            }else if(line.startsWith("f ")){
                faces += line + "\n";
            }
        }
        this.faces = faces;
        double[][] matrix_raw = new double[matrix.size()][3];
        int i = 0;
        for (double[] d: matrix){
            matrix_raw[i++] = d;
        }
        return new Matrix(matrix_raw).transpose();
    }

}
